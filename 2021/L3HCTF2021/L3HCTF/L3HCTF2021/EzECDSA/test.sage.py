

# This file was *autogenerated* from the file /mnt/c/Users/16953/Desktop/密码学归档/mmxctf/赛题归档/crypto-challenges/L3HCTF2021/EzECDSA/test.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f = Integer(0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798 = Integer(0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798); _sage_const_0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8 = Integer(0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8); _sage_const_0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141 = Integer(0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141); _sage_const_1 = Integer(1); _sage_const_8 = Integer(8); _sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_100 = Integer(100); _sage_const_256 = Integer(256); _sage_const_102 = Integer(102); _sage_const_101 = Integer(101)#! /usr/bin/sage
from sage.all import *
from sage.groups.generic import bsgs
from Crypto.Util.number import *
import gmpy2
import hashlib
import socketserver
import os,random,string
from hashlib import sha256
from Crypto.Util.number import bytes_to_long
p = _sage_const_0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f 
a = _sage_const_0 
b = _sage_const_7 
xG = _sage_const_0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798 
yG = _sage_const_0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8 
n = _sage_const_0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141 
h = _sage_const_1 
zero = (_sage_const_0 ,_sage_const_0 )
G = (xG, yG)
kbits = _sage_const_8 


dA = random.randrange(n)
print(type(dA))
# dA = int(32703019445086741813420098481380379496870768336466025291166428319868396091971)

Public_key = mul(dA, G)
def add(p1, p2):
    if p1 == zero:
        return p2
    if p2 == zero:
        return p1
    (p1x,p1y),(p2x,p2y) = p1,p2
    if p1x == p2x and (p1y != p2y or p1y == _sage_const_0 ):
        return zero
    if p1x == p2x:
        tmp = (_sage_const_3  * p1x * p1x + a) * gmpy2.invert(_sage_const_2  * p1y , p) % p
    else:
        tmp = (p2y - p1y) * gmpy2.invert(p2x - p1x , p) % p
    x = (tmp * tmp - p1x - p2x) % p
    y = (tmp * (p1x - x) - p1y) % p
    return (int(x),int(y))

def mul(n, p):
    r = zero
    tmp = p
    while _sage_const_0  < n:
        if n & _sage_const_1  == _sage_const_1 :
            r = add(r,tmp)
        n, tmp = n >> _sage_const_1 , add(tmp,tmp)
    return r

def sha256(raw_message):
    return hashlib.sha256(raw_message).hexdigest().encode()

def _sha256(raw_message):
    return bytes_to_long(hashlib.sha256(raw_message).digest())
kk =[]
rr =[]
ss = []
hh = []
for _ in range(_sage_const_100 ):
    
    msg = str(_)
    hash = _sha256(msg.encode())
    k = random.randrange(n)
    kp = k % (_sage_const_2  ** kbits)
    k=k-kp
    P = mul(k, G)
    r_sig = P[_sage_const_0 ]
    k_inv = gmpy2.invert(k, n)
    s_sig = (k_inv * (hash + r_sig * dA)) % n
    kk.append(kp)
    ss.append(s_sig)
    rr.append(r_sig)
    hh.append(msg)
tt=[]
uu =[]
for i in range(len(ss)):
    tt.append(r*inverse_mod(_sage_const_256 *ss[i],n))
    uu.append(hh[i]*inverse_mod(_sage_const_256 *ss[i],n))
l=_sage_const_8 


ct = _sage_const_1 /_sage_const_2 **l
cu = n/_sage_const_2 **l
M = [[_sage_const_0  for i in range(_sage_const_102 )] for j in range(_sage_const_102 )]
for i in range(_sage_const_100 ):
    for j in range(_sage_const_100 ):
        M[i][j] = n
for i in range(_sage_const_100 ):
    M[_sage_const_100 ][i] = tt[i]
    M[_sage_const_101 ][i] = uu[i]
M[_sage_const_100 ][_sage_const_100 ] = ct
M[_sage_const_101 ][_sage_const_101 ] = cu
M = matrix(M)
print('start LLLing.....')
B = M.LLL()
# A = matrix([[1,2,3],[1,2,3],[1,2,34]])
# A.LLL()
f = open('./data','w+')
for i in B:
    f.write(str(list(i))+'\n')


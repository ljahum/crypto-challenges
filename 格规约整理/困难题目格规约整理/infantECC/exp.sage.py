

# This file was *autogenerated* from the file exp.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_512 = Integer(512); _sage_const_0 = Integer(0); _sage_const_100 = Integer(100); _sage_const_256 = Integer(256)
from sage.all import log


log2 = lambda val: f"{float(RR(log(abs(val),2))):.3f}"
proof.arithmetic(False)

from random import randint, seed
# seed(101)

p = q = _sage_const_1 
while p % _sage_const_3  != _sage_const_2 :
    p = next_prime(randint(_sage_const_1 ,_sage_const_2 **_sage_const_512 ))
while q % _sage_const_3  != _sage_const_2 :
    q = next_prime(randint(_sage_const_1 ,_sage_const_2 **_sage_const_512 ))

n = p*q
R = Zmod(p*q)
Mx = R.random_element()
My = R.random_element()
b = My**_sage_const_2  - Mx**_sage_const_3 

Ep = EllipticCurve(GF(p), [_sage_const_0 ,b])
Eq = EllipticCurve(GF(q), [_sage_const_0 ,b])
E = EllipticCurve(R, [_sage_const_0 ,b])

Ecard = Ep.cardinality()*Eq.cardinality()

#r = random_prime((p^^q)>>100)
r = next_prime(randint(_sage_const_0 , (p^q)>>_sage_const_100 ))
s = inverse_mod(r, Ecard)

print("   s", log2(s))
print("   r", log2(r))
print("rmax", log2((p^q)>>_sage_const_100 ))

spt = s*E(Mx, My)
randpt = randint(_sage_const_0 , Ecard)*E(Mx, My)

from hashlib import sha256
from Crypto.Util.number import bytes_to_long, long_to_bytes
flag = b"RCTF{Copper5mith_M3thod_f0r_ECC}"
v = r^(bytes_to_long(sha256(long_to_bytes(Mx)).digest())^bytes_to_long(flag))<<_sage_const_256 


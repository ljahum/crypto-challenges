

# This file was *autogenerated* from the file ./test.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_7 = Integer(7); _sage_const_5 = Integer(5); _sage_const_256 = Integer(256); _sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_24 = Integer(24)
Zx = ZZ['x']; (x,) = Zx._first_ngens(1)
from icecream import *
f = Zx([_sage_const_1 ,-_sage_const_1 ,_sage_const_1 ,_sage_const_1 ,-_sage_const_1 ])
n=_sage_const_7 
d=_sage_const_5 
q=_sage_const_256 
p = _sage_const_3 

def mul(f, g):
    return (f * g) % (x ** n-_sage_const_1 )


def bal_mod(f, q):
    g = list(((f[i] + q//_sage_const_2 ) % q) - q//_sage_const_2  for i in range(n))
    return Zx(g)


def random_poly(d):
    assert d <= n
    result = n*[_sage_const_0 ]
    for j in range(d):
        while True:
            r = randrange(n)
            if not result[r]:
                break
        result[r] = _sage_const_1 -_sage_const_2 *randrange(_sage_const_2 )
    return Zx(result)


def inv_mod_prime(f, p):
    T = Zx.change_ring(Integers(p)).quotient(x ** n-_sage_const_1 )
    return Zx(lift(_sage_const_1  / T(f)))


def inv_mod_powerof2(f, q):
    assert q.is_power_of(_sage_const_2 )
    g = inv_mod_prime(f, _sage_const_2 )
    while True:
        r = bal_mod(mul(g, f), q)
        if r == _sage_const_1 :
            return g
        g = bal_mod(mul(g, _sage_const_2  - r), q)
# f = random_poly(5)


Zx = ZZ['x']; (x,) = Zx._first_ngens(1)
f = Zx([-_sage_const_1 ,_sage_const_0 ,_sage_const_1 ,-_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,-_sage_const_1 ])
g = Zx([_sage_const_1 , _sage_const_1 , _sage_const_0 , -_sage_const_1 , -_sage_const_1 , _sage_const_1 ,_sage_const_1 ])
fp = inv_mod_prime(f, p)
fq = inv_mod_powerof2(f, q)
# h=(3*mul(fq,g))

h = bal_mod((p*mul(fq, g)),q)
# ==============================
m = random_poly(_sage_const_7 )
r = random_poly(_sage_const_3 )
ic(m)
ic(r)
# =============================
c = bal_mod(mul(h,r)+m,q)
ic(c)


# ic(mul(f,c))
a = bal_mod(mul(f,c),q)
m1 = bal_mod(mul(a,fp),p)
ic(m1)
if(m==m1):
    print("================dec success================")
print("public key")
ic(h)
pub_key_coeffs = h.coefficients()
ic(pub_key_coeffs)
# M = matrix(2*n, 2*n,0)
# for i in range(n):
#     M [i,i]=1
#     # for j in range(n):
#     #     M[i,j+n]=pub_key_coeffs[(j-i)%n]
#     for j in range(n):
#         M[i, n+j] = pub_key_coeffs[j]
#     pub_key_coeffs.insert(0, pub_key_coeffs.pop())
#     M[i+n,i+n]=q
# print(M)
# basis = M.BKZ(block_size=24)
M_h = Matrix(n*_sage_const_2 , n*_sage_const_2 , _sage_const_0 )
for i in range(n):
    M_h[i, i], M_h[n+i, n+i] = _sage_const_1 , q
    for j in range(n):
        M_h[i, n+j] = pub_key_coeffs[j]
    pub_key_coeffs.insert(_sage_const_0 , pub_key_coeffs.pop())

M_r = M_h.BKZ(block_size=_sage_const_24 )
t = [i for i in M_r[_sage_const_0 ]]
print(M_r)
print("f = Zx([-1,0,1,-1,1,0,-1])")
print(t)


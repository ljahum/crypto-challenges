rsa的部分很简单：

- h1和n gcd可得到r
- mod其实就是n^3。假设p低400位为x，对h2展开可以得到Ca2\*(3n）^2 + Ca1\*3n + 1 = h2，因此可在ZZ下求根得到p低位，然后使用coppersmith解出p

这样n就factor了

序列部分要麻烦一些：
$$
大概是个级数：\\
point的返回值sum = \sum_{i=0}^{n}coe_i(x-1)^{1/2-i}\\
coe_i = coe_{i-1}^2 * \frac{(1/2-i+1)}{i}\\
调试后发现sum每次返回center的根号值\\
那么k就是根号n的积分，k=2/3 * n ^ {3/2}
$$

exp:

```
from Crypto.Util.number import long_to_bytes, isPrime
from Crypto.Util.strxor import strxor

flag_len = 42
n = 1885106209951408608833065466098355578239648885277085979696889428331716535742564778501798478665957825315340421821880653818505857049636611632357321104069926874970489073929053910350131880591544986024406953378391135673202854750625745159391997973535848495128365477217006260495413869532372418221652962946340513593002422433536479789576519469228846773250447077165756739529520975715667675188738514871033908115371290569902086064227476952606366538782284487477820835988316471
c = 696238728213276154324787695659767792043458798396732235983493075871691401810545168845655490352789752222363100922123671319198981013421632076090146254867823593523050502577701155837063376958530879006719716789887624440134559774538443909463537086796915613123528679984244371544503657821859556837415229166015914540860398289216765611441964228176020361651359395184571105468667815326494558761738459063914192172836518999575866452752941368767971539919141604299843463853501960
hint1 = 47533994701669017942592643580845693193316601935087923279407365999451221242084261195588230994183718077379066856479267476895986608547324057765879168010176037349172136581929046771540241367625486215731295814611283581608613208990206581757576978017732022062210538697720930605552259306749633658032304554578427461842934055558865521604512892691323385156889995854702621568441768712619224249280792783364635307739215957762771386413831279443875185633720270001928747743847856394847878232194076679733830705297410959656270945532930199517880949
hint2 = 1345739841248959791137389026125065605121513428784838684290299665636596562317989590469829195181078904857051392378877013458099983407103737518119999468489762053545474516182879516762580472262640794849609626308003164739287189671066241628052826558582865342176036139097546843281565147798609965645514151827840249686650855385385323417455247722134760335695053787221300451942370377598800841980049138341564555801417479362085565640973199260631136149016266661293883650801813550118778433333591258278147003619871962070136454674193198696690506092831171400435490432196636796719177624389194619648086397178720207413652618636521150924913978530986709499047969775311955879302418093270101476537853298615347062384026172441455857088955847766335746521291043747795520485020303040819568036819058385444936925860671650596681910380157657689041971132993731048618045570715513584627109356139903842365556697314631573799394266292587334468008221427502353566938518574247502783245674619641519095644135976062817840893465238031354234069073928763492529419021632732679912738674105898149050223970723297059883534089683179512881491210176114419520070007595698242827625902377045860953285447617249204919971737086366
r = GCD(n,hint1)
P.<p> = PolynomialRing(ZZ)
f = ((9)*n^2/2*((p*(p-1))) +  3*n*p + 1) - hint2
p_low = int(f.roots()[0][0])
kbits = 512 - 400
n_ = n // r
P.<x> = PolynomialRing(Zmod(n_))
g = p_low + x * 2^400
x0 = g.monic().small_roots(X=2^kbits, beta=0.4)[0]
p = int(p_low + x0 * 2^400)
q = n//p//r
assert all([isPrime(i) for i in [p,q,r]])
phi = (p-1)*(q-1)*(r-1)
e = 65537
d = inverse_mod(e,phi)
m = pow(c,d,n)
pad_flag = long_to_bytes(int(m))
k = int(2/3 * n ^ (3/2))
flag = strxor(long_to_bytes(k >> (k.bit_length() - 8 * flag_len)), pad_flag[:42])
print(flag)
#flag{84934a62-f932-968c-fa88-22f0284c0e8e}
```


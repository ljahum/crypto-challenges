自行生成一组数据，假设 leak1 = p2+q2 ，用求根公式计算p发现算出来的 partial p 的大约低400位和真正的p不对，将stage1转化为p high bits leak且unknown low 400 bits的问题可以解决

```python
from Crypto.Util.number import getPrime,GCD

from gmpy2 import *

n2 = 20369481027961668058257949652346266097405331865071244844827896944882851755421021125005038786750268341013032202394581223828526073179263634639721089663050687773353438686984875196973012077948955566738301337866191557952973517042420660699281973702694965572488938789954679350791243570953680441483360036599350550534192027759384675611155970913348616382186229565994100357427843446265863186624731991521034305958565644266001622849342042747046352413268149901263629515623929619659379883036239511300563910486156582808698915297257307692017642458823600500445082987244477251123335410633989767118317681371314078169733374888688620813839
leak1 = 110733171993470709195465104383246525062178362778220972191726705114514369848757940664883819735824778128179586221599072975207093223575285541338555960658178287486722693023393688158120847028382
n = n2
B = leak1<<400
# delta = ((B>>400)<<400)**2-4*n
delta = B**2-4*n
tmp = iroot(delta,2)
print(tmp)
tmp = iroot(delta,2)[0]
p1 = (B-tmp)//(2)
print(p1)

p_high = 134541671225018271403953787373408507465730892003631249716123043010464351342881237505189677861071006923092011330983761091184598196512437449946447759771425031294468141216072218813533336313657524467880090272881006395913313631318750309915844569487401367971190613041647395141514821670753155742964430170132258004003
# n = 
R.<x> = PolynomialRing(Zmod(n))
f = p_high + x
tmp = f.small_roots(2**454,0.4)
print(tmp)
x = tmp[0]
P = int(x+p_high)
print(n%P)
q = n//P
print("p=",P)
print("q=",q)
#p= 134541671225018271403953787373408507465730892003631249716123043010464351342881237505189677861071006923092011330983761091184598196512437449946447759771425031294468141216072218813533336313651823171925311705682558765317115569680736707328403560829555033008387085671352235353814183291570781754064065104600110875621
# q= 151399048655298148018688323609718705920605086712318698086250277971491481779504840614471253946764630599745412866850500656954922361816231030123945084396794404269982437117950486373905356265950808460057643971210951709676705550508291196476405125057071271317182732652055355984683359771176148502822187125614565868259
from Crypto.Util.number import *

n1 = 105813626754830369767796578799226643889033227412658130226893708851110720416468059965713264658478299377654212587044247669928410442281831382577490105352633718272894531572352233211881056495752193201866649055622358234888531194346296702453105176147272971386928767457928148705433435309063146652094354833396307613911
n2 = 20369481027961668058257949652346266097405331865071244844827896944882851755421021125005038786750268341013032202394581223828526073179263634639721089663050687773353438686984875196973012077948955566738301337866191557952973517042420660699281973702694965572488938789954679350791243570953680441483360036599350550534192027759384675611155970913348616382186229565994100357427843446265863186624731991521034305958565644266001622849342042747046352413268149901263629515623929619659379883036239511300563910486156582808698915297257307692017642458823600500445082987244477251123335410633989767118317681371314078169733374888688620813839
leak1 = 110733171993470709195465104383246525062178362778220972191726705114514369848757940664883819735824778128179586221599072975207093223575285541338555960658178287486722693023393688158120847028382
enc = 3724360314735337348015983350518926695244720487101059718828225257324872465291143851090607580822961202894850524395217010317254775500983396154162166500198523991652838543842978138662752717532358799622372813160573374563924704242911344052149200174619645796187521459916955545794017698320367273671936314947729523150627463505338870024421481261166504454532278895870561732979282672259730923724762173494886613682487373643406390205027508946750313076817576295795818790961232101069994823561840743308871216879655652136743807002025483269687509388947008928281179566366429525183899914275273098400627187051739816901887290337980735995613
c = 38127787578353827234498259231834082660893046004292279030517959465543348558091033172704284501791369355347078715874056471582324178524957666710131669794646539355849074198396968523041568909435662208846480656877184197877122598569708545477705274221697660270808685794034776172296500330563270867517390911486555286886

p2= 134541671225018271403953787373408507465730892003631249716123043010464351342881237505189677861071006923092011330983761091184598196512437449946447759771425031294468141216072218813533336313651823171925311705682558765317115569680736707328403560829555033008387085671352235353814183291570781754064065104600110875621
q2= 151399048655298148018688323609718705920605086712318698086250277971491481779504840614471253946764630599745412866850500656954922361816231030123945084396794404269982437117950486373905356265950808460057643971210951709676705550508291196476405125057071271317182732652055355984683359771176148502822187125614565868259
# enc = pow(leak2,e,n2)
e = 65537
phi_2 = (p2-1)*(q2-1)
d2 = inverse(e,phi_2)

leak2 = pow(enc,d2,n2)

print(leak2)
```

stage2是p 低bits泄露，最低缺失的5bit直接遍历0到64，再生成几组数据卡一下copperSmith的上界和下界,
题目数据正好跑出来一组解，测试后确定为n1的因数
脚本：

```python
from Crypto.Util.number import *
# p1 = getPrime(512)
# q1 = getPrime(512)
# print(p1,q1)

from Crypto.Util.number import *

n1 = 105813626754830369767796578799226643889033227412658130226893708851110720416468059965713264658478299377654212587044247669928410442281831382577490105352633718272894531572352233211881056495752193201866649055622358234888531194346296702453105176147272971386928767457928148705433435309063146652094354833396307613911
leak2 = 22334810767801800995021872014176778873829048161801414909315794486047873481911273730826962574216771288781

N = n1
pl = leak2

for i in range(64):
    padding = i
    
    # print((pl<<5)+padding - (p1 & ((1 << 350) - 1)))
    par=(pl<<5)+padding
    mod=pow(2,350)

    PR.<x> = PolynomialRing(Zmod(N))
    f=x*mod+par

    f=f.monic()
    tmp = f.small_roots(X=2^200,beta=0.15)
    print(i,tmp)  
x = 4900544356592211265646431814937281576562955146062
padding = 7
par=(pl<<5)+padding
mod=pow(2,350)
P = x*mod+par
print(GCD(P,n1))

```
flag 脚本
```python
leak2 = 22334810767801800995021872014176778873829048161801414909315794486047873481911273730826962574216771288781

# copper
p1 = 11239391699442192016394616757221620834717629054697859972076207292592548525033647125013001671320452447403380966370885392089905799108483165855335320142731687

q1 = n1//p1
# print(q1)
# print(n1%p1)
q1 = 9414533240271523909175466549989578413560381929724653857969276831718175551727032446390484582550970699995107874013408751551550726534204653674601330352393553

# c = pow(bytes_to_long(flag),e,n1)
phi_1 = (p1-1)*(q1-1)
d1 = inverse(e,phi_1)
m2 = pow(c,d1,n1)
print(long_to_bytes(m2))
# flag{9995eae8acaac286c7b72e50e5258dc3}```
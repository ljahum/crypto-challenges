# CIVC2023-人称小湖湘杯

## Easy bog

> 很明显是想写easybag 但是bag写错了
> 

背包加密，但是对密文取模了

考虑

$$
C=c+k*p \ (mod\ n)
$$

对k遍历找C 阅读源码可知k的大小大概在40左右

保险起见从0遍历到80

```python

p = 85766816683407427477074053090759168259205489535331001301483049660772943816017
pubkey = [58890813098389592716367918664418237809399998613202441049117852003453550490043, 255886907973292033549191761914277947638378726729170162403000263307778539588, 43666147543837562983744529128391108960442814393989688186615627619841168438881, 2289339843351034938706095739069649849491797527322909177303809837660115875707, 41213482604182795008139260226694469358720652561587117539105919206178583341309, 85123975988270149359269904030278272256150702593339117634318036869051474541673, 38499515653492727036642516425661144597669644770181333309684190745152037999340, 20485509602350760468364550436683434882775269798789922529010411809186809838027, 66201868699675751260618542402171897519442339400362102112029773068389836772496, 5928498980938052035989976608996334019121526162545586177960440867589564370967, 50886730626726574520144515855606763616811548330471900085065588158010347676677, 64024533350992434764550819938965710849249693930938822302806256939206336927327, 38725701074483250591450474606717766666514853596721960873869603150079957176979, 79217343443391443055559755031159399927770013676937883189341106207746097977107, 61550584018851036114215415812034871024308694207855706560554908679054705909070, 18943452821091669663831772224349497605704279324611723330470460453532875854668, 19589987578009659601683539978459498259975975776374959927024576839483511789830, 30455762424330442645213719258885752997650973641135913878741104126501286615202, 58949965807078946897782791856062155685595594220625894016492979510745067947620, 62055731853485887582338078878228949009560282473783423335829652944841334703073, 9968050471897160901950463089357618812125361692340159762344476181267684171496, 82879622776859731032127240994822860125030485017752550449574280896284319539559, 4801338348200265259854446071344823901330707085102509710655971928319789477063, 45731791006706217374257923546738746982354369452894895184784691821888225473116, 67249651561046962535594292263727781436622305014470811080407605464069397278541, 74549581000796086938735007821116567870037873934415647996983670510761843574950, 53927163931460713770577528602376533863752551014779597870421933008696943680646, 56674817179749773825254339411582187056553125580899575215919582277873475282705, 46486618405288541635832334168373891479516241585245833202819962034096805786948, 33438500041468604615663063367413201369385488295864836452725688027946579037027, 67664099966578778667405575319488959391557099474146663546553930271609270514413, 45447815671440655615043306804023843286416205143693188321756314646855229497538, 11725972638697133812198141962081533057131109523301554105107846876476492922863, 64289489702331472745122326714411510149286883423778995697545620572730495023564, 57994575257987111046854716965859364231330618527165005046088441624813910607490, 14668229647185139513680523686559656096579435616501772089580139136432744069528, 17932811002316804580991874481669739042847138206519622106023735880404179858139, 5331195663859739712428554823168168360812478289288952467823046758773036202890, 74552793814948855649083379813894922159371588934498467412076815493098565156965, 44935994020454630627073800850452460158487760266394408710221643505798360283738, 56729956460199305019441584184914729272661532037080935244087594435220086006307, 62039396792619765440106521363503635264208869754554560630026111496679072778122, 2393458745997765849524009470841489934632527663821258015836036776013536950950, 35915327454351624449823951016325751779776476237317012289496757290655725512173, 32606524479615026657452402620774183996842863618201886022072527830448469143354, 63235637104235763521471020678482591762365962539497201272446150774560661623146, 62208964066864651499810642926855154855961192109426476051220581622874074871556, 56823425142073561606336827683244447153122191299012994793162957373419782442861, 60885675233604760515790987357657130734130927344692532134660791434444881730069, 70128263220978378037998154126965802527577393332688627564386146841574995052881, 71018980922731664798406835410011497130959699315348431777949257381109611662531, 12143164079299710577697191074655687226341720767219380493916347970636555672200, 13508918371738967514239962849170666297725816564248068619597724335815422874867, 35455956156846758401498039994914987477656410741995261921339242861566953715810, 69980758495467248406706658186358315365421963514406314839633132920772753269590, 40780609781497584108689952068487274243081363044494223353377248536197342087646, 44867942499383360300066493293729414921480295687316596135570022888723461284905, 82725154870798626926322339306353417520587153667878451856611421219700157524903, 25126631681527477467395254546272084567454410334950820629891182857858739056234, 6951466886617047161399523857762365328179011042304277010521273986635895511090, 76348861623318422648322072872825713398471251831589343473949016976971223635877, 56205107190224957419682681113714452084261733562014707901087589292788540501506, 18117892543394976645523077630904329147251317704285881519049138075260678609853, 44808031105096301006447146332872279574072682041430481888991436113801413524922, 49253422883319286749223459668126849556879848229728760990408851547046135426202, 84189814930926817953967035166781168797567323089104013113646102708978330223462, 47137140069594189485896203757476808738350291684312377044596204628988007490802, 40801572088832002265546622948401731702850273201235765228409527972304470614013, 66031049946459598112632104872606456117378438456948859102185817862671625118362, 81720181560222737179789740743588444616843925127263616533094516919384531350798, 22799062566507850812703708400514738660780510100747243720001217935586864713536, 19636898235593770858368519750634152409107475396982151534080287393055054087250, 29019136605948188309201641456999919579306004440518777086603961225647602320689, 79880698495154758609432245210109366091585969807890967815410904513080769679673, 9333444307040962156247586346311311869921891214405652789959336947220586492578, 5389291816105059661723219597627983160117906098832235782666626188832333763452, 80140247201709476779769310874536378021073864035213177889595402673752593492257, 10265989744904418075184606188771633319731922237097882332727796873595806941649, 28947186543573208323555611612621027283989204690818732739083074045376664847781, 76665830939598023116888796550932971936723367285838797618563918377195976634315]
c = 1381426073179447662111620044316177635969142117258054810267264948634812447218

n = 80
for j in range(80):
    L = Matrix(ZZ, n+1, n+1)

    for i in range(len(pubkey)):
        L[i, i] = 2
        L[i, -1] = pubkey[i]
    L[-1, :] = 1
    tmp = c+p*j
    L[-1, -1] = c+p*j
    tmp = L.LLL()
    print(tmp[0])

```

当k=23
得到向量 (-1, -1, -1, -1, 1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, -1, 1, -1, -1, 1, 1, 1, 1, -1, -1, -1, 1, 1, 1, 1, -1, 1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, 1, 1, -1, 1, 1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1, 1, 1, -1, -1, -1, -1)

解flag，尝试-1为1,1为0时得到flag

```python
from Crypto.Util.number import *
from hashlib import md5

a=  [-1, -1, -1, -1, 1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, -1, 1, -1, -1, 1, 1, 1, 1, -1, -1, -1, 1, 1, 1, 1, -1, 1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, 1, 1, -1, 1, 1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1, 1, 1, -1, -1, -1, -1]
l = ''
for i in a:
    if(i==-1):
        l+='1'
    else:
        l+='0'
print(l)

tmp =0b11110101111111110100010010110000111000010101000000010011110010010110010010001111
rr = long_to_bytes(tmp)

flag = "flag{"+rr.hex()+"}"
flag_md5 = md5(flag.encode()).hexdigest()
print(flag)
print(flag_md5)

```

## Easy random

```python
from random import Random
from hashlib import md5
rng = Random()
leak = []
for i in range(1250):
    leak.append(rng.getrandbits(16))
m = rng.getrandbits(64)
flag = "flag{"+str(m)+"}"
print(flag)
flag_md5 = md5(flag.encode()).hexdigest()
f = open("output.txt","w")
f.write(f"leak = {leak}\n")
f.write(f"flag_md5 = {flag_md5}\n")
f.close()
```

https://github.com/icemonster/symbolic_mersenne_cracker

github脚本梭哈

## easy rsa

> 没啥难度，coppersmith基本功
> 

生成几组数据发现

`leak1 = (p2+q2) >> 400`

将leak1直接作为 p2+q2放进去计算可以得到p2（或者q2）的高位，但低位大概有400位丢失，Coppersmith攻击求解

第二阶段

`leak2 = (p1 & ((1 << 350) - 1)) >> 5`

还是 用Coppersmith攻击求解，不过是已知低位求高位，

丢失的最低位从0遍历到32即可求解

完整脚本

```python
from Crypto.Util.number import getPrime,GCD,inverse,long_to_bytes

from gmpy2 import *
n1 = 105813626754830369767796578799226643889033227412658130226893708851110720416468059965713264658478299377654212587044247669928410442281831382577490105352633718272894531572352233211881056495752193201866649055622358234888531194346296702453105176147272971386928767457928148705433435309063146652094354833396307613911
n2 = 20369481027961668058257949652346266097405331865071244844827896944882851755421021125005038786750268341013032202394581223828526073179263634639721089663050687773353438686984875196973012077948955566738301337866191557952973517042420660699281973702694965572488938789954679350791243570953680441483360036599350550534192027759384675611155970913348616382186229565994100357427843446265863186624731991521034305958565644266001622849342042747046352413268149901263629515623929619659379883036239511300563910486156582808698915297257307692017642458823600500445082987244477251123335410633989767118317681371314078169733374888688620813839
leak1 = 110733171993470709195465104383246525062178362778220972191726705114514369848757940664883819735824778128179586221599072975207093223575285541338555960658178287486722693023393688158120847028382
enc = 3724360314735337348015983350518926695244720487101059718828225257324872465291143851090607580822961202894850524395217010317254775500983396154162166500198523991652838543842978138662752717532358799622372813160573374563924704242911344052149200174619645796187521459916955545794017698320367273671936314947729523150627463505338870024421481261166504454532278895870561732979282672259730923724762173494886613682487373643406390205027508946750313076817576295795818790961232101069994823561840743308871216879655652136743807002025483269687509388947008928281179566366429525183899914275273098400627187051739816901887290337980735995613
c = 38127787578353827234498259231834082660893046004292279030517959465543348558091033172704284501791369355347078715874056471582324178524957666710131669794646539355849074198396968523041568909435662208846480656877184197877122598569708545477705274221697660270808685794034776172296500330563270867517390911486555286886

# stage 1
n = n2
B = leak1<<400
tmp = iroot(B**2-4*n,2)[0]
p1 = (B-tmp)//(2)
# print(p1)
p_high = 134541671225018271403953787373408507465730892003631249716123043010464351342881237505189677861071006923092011330983761091184598196512437449946447759771425031294468141216072218813533336313657524467880090272881006395913313631318750309915844569487401367971190613041647395141514821670753155742964430170132258004003
# n = 
R.<x> = PolynomialRing(Zmod(n))
f = p_high + x
tmp = f.small_roots(2**454,0.4)
# print(tmp)
x = tmp[0]
P = int(x+p_high)
# print(n%P)
# 0
q = n//P
print("p2=",P)
print("q2=",q)
p2= 134541671225018271403953787373408507465730892003631249716123043010464351342881237505189677861071006923092011330983761091184598196512437449946447759771425031294468141216072218813533336313651823171925311705682558765317115569680736707328403560829555033008387085671352235353814183291570781754064065104600110875621
q2= 151399048655298148018688323609718705920605086712318698086250277971491481779504840614471253946764630599745412866850500656954922361816231030123945084396794404269982437117950486373905356265950808460057643971210951709676705550508291196476405125057071271317182732652055355984683359771176148502822187125614565868259

e = 65537
phi_2 = (p2-1)*(q2-1)
d2 = inverse(e,phi_2)
leak2 = pow(enc,d2,n2)
# print(leak2)

# stage 2
leak2 = 22334810767801800995021872014176778873829048161801414909315794486047873481911273730826962574216771288781
n1 = 105813626754830369767796578799226643889033227412658130226893708851110720416468059965713264658478299377654212587044247669928410442281831382577490105352633718272894531572352233211881056495752193201866649055622358234888531194346296702453105176147272971386928767457928148705433435309063146652094354833396307613911
n2 = 20369481027961668058257949652346266097405331865071244844827896944882851755421021125005038786750268341013032202394581223828526073179263634639721089663050687773353438686984875196973012077948955566738301337866191557952973517042420660699281973702694965572488938789954679350791243570953680441483360036599350550534192027759384675611155970913348616382186229565994100357427843446265863186624731991521034305958565644266001622849342042747046352413268149901263629515623929619659379883036239511300563910486156582808698915297257307692017642458823600500445082987244477251123335410633989767118317681371314078169733374888688620813839
leak1 = 110733171993470709195465104383246525062178362778220972191726705114514369848757940664883819735824778128179586221599072975207093223575285541338555960658178287486722693023393688158120847028382
enc = 3724360314735337348015983350518926695244720487101059718828225257324872465291143851090607580822961202894850524395217010317254775500983396154162166500198523991652838543842978138662752717532358799622372813160573374563924704242911344052149200174619645796187521459916955545794017698320367273671936314947729523150627463505338870024421481261166504454532278895870561732979282672259730923724762173494886613682487373643406390205027508946750313076817576295795818790961232101069994823561840743308871216879655652136743807002025483269687509388947008928281179566366429525183899914275273098400627187051739816901887290337980735995613
c = 38127787578353827234498259231834082660893046004292279030517959465543348558091033172704284501791369355347078715874056471582324178524957666710131669794646539355849074198396968523041568909435662208846480656877184197877122598569708545477705274221697660270808685794034776172296500330563270867517390911486555286886

N = n1
pl = leak2
for i in range(64):
    padding = i
    
    # print((pl<<5)+padding - (p1 & ((1 << 350) - 1)))
    par=(pl<<5)+padding
    mod=pow(2,350)

    PR.<x> = PolynomialRing(Zmod(N))
    f=x*mod+par

    f=f.monic()
    tmp = f.small_roots(X=2^200,beta=0.15)
    if(len(tmp)!=0):
        x = tmp[0]
        print('x=',x)
        # x = 4900544356592211265646431814937281576562955146062
        # i = 7
        padding = i
        par=(pl<<5)+padding
        mod=pow(2,350)
        P = x*mod+par
        if(n1%P==0):
            p1=P
            # ring -> int
            q1=n1//int(P)
            phi_1 = (p1-1)*(q1-1)
            d1 = inverse(e,phi_1)

            m2 = int(pow(c,d1,n1))
            print(long_to_bytes(m2))
```

`b'flag{9995eae8acaac286c7b72e50e5258dc3}'`

## crypto_ezmath

LCG线性同余器求解，注意对求到p的序列后应该验证是否存在更小的最大公约数
求参数

```python
from Crypto.Util.number import *
def gcd(a,b): 
    if(b==0): 
        return a 
    else: 
        return gcd(b,a%b) 
s = [288530505749272642500730917886204398531, 63547143998110685331032679758907988154, 15151206512028268617888756820805603406, 268092204209244869520724955865278855216, 261067075335188593563542448889694952077, 138067838531633886698552659065694918861, 201319433320428898153580935653793106657]
t = []
for i in range(len(s)-1):
    t.append(s[i]-s[i-1]) 
all_n = []
for i in range(len(s)-3):
    all_n.append(gcd((t[i+1]*t[i-1]-t[i]*t[i]), (t[i+2]*t[i]-t[i+1]*t[i+1]))) 
for i in range(len(all_n)-1):
    tmp = GCD(all_n[i+1],all_n[i])
    print(isPrime(tmp),tmp)
# exit()
all_n=[312769358113056565136009929613710078319]
A_list =[]
B_list =[]
seed_list =[]
N_list =[]
for n in all_n:
    
    a=(s[2]-s[1])*inverse((s[1]-s[0]),n)%n
    ani=inverse(a,n)
    b=(s[1]-a*s[0])%n
    seed = (ani*(s[1]-b))%n
    A_list.append(a)
    B_list.append(b)
    seed_list.append(seed)
    N_list.append(n)
    # plaintext=seed
    # print(long_to_bytes(plaintext))
f = open('data.py',"w+")
print("A_list=",A_list,file=f)
print("B_list=",B_list,file=f)
print("seed_list=",seed_list,file=f)
print("N_list=",N_list,file=f)
```

结果存在data.py里面，理论上可能有多个情况，但题目的数据只得到一种情况
求flag：

```python
from Crypto.Util.number import *
from icecream import *
import json
from random import *
from data import A_list,B_list,seed_list,N_list

# s0 = [262511059665565542818742542680700347828, 287010904654436360145740056415861584813, 151812673943463405598104613454321947811, 154283457183801144036527862621937097062, 162169576764079744831218742042754936958, 237702446699526960097645789449246246726, 79991781927641983195598094004226339192]
s0 = [288530505749272642500730917886204398531, 63547143998110685331032679758907988154, 15151206512028268617888756820805603406, 268092204209244869520724955865278855216, 261067075335188593563542448889694952077, 138067838531633886698552659065694918861, 201319433320428898153580935653793106657]
# s0 =  [187347920947732167502669966469089592988, 172005321449729609569402112498877055039, 145497893129324793561010674772723412127, 7509141152031069488051378936726327124, 161799527734944103028691846155098689330, 17868038022722036141824368556075768437, 130935170227910213439548831640869043803]
def exp(p,seed,A,B):
    class prng:
        n = p
        # a,b = [randint(2, p - 1) for _ in range(2)]
        a = A
        b = B
        
        def __init__(self,seed):
            self.state = seed
        def next(self):
            self.state = (self.state * self.a + self.b) % self.n
            return self.state

        
    def main():
        gen = prng(seed)
        s = [seed]
        s.append(gen.next())
        s.append(gen.next())
        s.append(gen.next())
        s.append(gen.next())
        s.append(gen.next())
        s.append(gen.next())
        
        print(s)
        # f = open("output2.txt",'w')
        # json.dump(s,f)
        # f.close()
        flag = "flag{"+str(gen.next())+"}"
        print(s==s0,flag)

    main()

for i in range(len(A_list)):
    p = N_list[i]
    a = A_list[i]
    b = B_list[i]
    seed = seed_list[i]
    exp(p,seed,a,b)
#True flag{302184756857257140159769321021979097116}
```

用s序列验证flag的有效性